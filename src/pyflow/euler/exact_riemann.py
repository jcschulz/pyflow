import numpy as np

from .state import PrimitiveState, ConservedState

class ExactRiemannSolver:
    def __init__(self, gamma=1.4):

        self.gamma = gamma
        self.G1 = (gamma - 1) / (2.0 * gamma)
        self.G2 = (gamma + 1) / (2.0 * gamma)
        self.G3 = 2.0 * gamma / (gamma - 1)
        self.G4 = 2.0 / (gamma - 1)
        self.G5 = 2.0 / (gamma + 1)
        self.G6 = (gamma - 1.0) / (gamma + 1.0)
        self.G7 = (gamma - 1.0) / 2.0
        self.G8 = gamma - 1.0

    def initialize(self, left : PrimitiveState, right : PrimitiveState):
        self.rhoL = left.rho
        self.rhoR = right.rho
        self.uL = left.u
        self.uR = right.u
        self.pL = left.p
        self.pR = right.p
        self.cL = np.sqrt(self.gamma * self.pL / self.rhoL)
        self.cR = np.sqrt(self.gamma * self.pR / self.rhoR)

        # Check for presure positivity
        if self.G4 * (self.cL + self.cR) <= self.uR - self.uL:
            raise RuntimeError('Vacuum is generated by Riemann Problem.')

    def flux(self, left : PrimitiveState, right : PrimitiveState):

        self.initialize(left, right)

        p_star, u_star = self.star_state()

        face = self.sample(p_star, u_star, 0.0)
        flux = np.zeros((3,len(p_star)))
        flux[0] = face.rho * face.u
        flux[1] = flux[0] * face.u
        flux[2] = face.u * (0.5 * face.rho * face.u**2 + face.p * self.gamma / (self.gamma - 1))

        return flux

    def star_state(self):

        p = self.__guess()
        u = 0

        u_diff = self.uR - self.uL
        dp = 1.0

        tolerance = 1.0e-5
        max_iterations = 100

        iteration = 0
        while dp > tolerance or iteration < max_iterations:
            F_left, dFdp_left = self.pressure_function(p, self.rhoL, self.cL, self.pL)
            F_right, dFdp_right = self.pressure_function(p, self.rhoR, self.cR, self.pR)

            p_next = p - (F_left + F_right + u_diff) / (dFdp_left + dFdp_right)

            dp = 2.0 * np.abs((p_next - p) / (p_next + p))

            p = p_next
            u = 0.5 * (self.uL + self.uR + F_right - F_left)

            iteration += 1

        return p, u

    def pressure_function(self, p_star, rho, c, p):

        if p_star <= p:
            # Rarefaction wave
            p_ratio = p_star / p
            return (
                self.G4 * c * (p_ratio**self.G1 - 1.0),
                p_ratio**(-self.G2) / (rho * c)
            )

        else:
            # Shock wave
            mass_flux = np.sqrt(self.G5 / rho / (self.G6 * p + p_star))
            return (
                (p_star - p) * mass_flux,
                (1.0 - 0.5 * (p_star - p) / (self.G6 * p + p_star)) * mass_flux
            )

    def __guess(self):

        c_avg = 0.25 * (self.rhoL + self.rhoR) * (self.cL + self.cR)
        ppv = 0.5 * (self.pL + self.pR) + 0.5 * (self.uL - self.uR) * c_avg

        ppv = max(0, ppv)
        p_min = min(self.pL, self.pR)
        p_max = max(self.pL, self.pR)

        p_ratio = p_max / p_min

        if p_ratio <= 2.0  and p_min <= ppv and ppv <= p_max:
            return ppv

        else:
            if ppv < p_min:

                pq = (self.pL / self.pR)**self.G1
                u_star = (pq * self.uL / self.cL + self.uR / self.cR + self.G4 * (pq - 1.0)) / (pq / self.cL + 1.0 / self.cR)
                ptl = 1.0 + self.G7 * (self.uL - u_star) / self.cL
                ptr = 1.0 + self.G7 * (u_star - self.uR) / self.cR
                return 0.5 * (self.pL * ptl**self.G3 + self.pR*ptr**self.G3)

            else:
                gel = np.sqrt((self.G5 / self.rhoL) / (self.G6 * self.pL + ppv))
                ger = np.sqrt((self.G5 / self.rhoR) / (self.G6 * self.pR + ppv))
                return (gel * self.pL + ger * self.pR - (self.uR - self.uL)) / (gel + ger)


    def sample(self, p_star, u_star, s):

        if s <= u_star:
            # Sampling point lies to the left of the contact discontinuity

            if p_star <= self.pL:
                # Left rarefaction

                if s <= self.uL - self.cL:
                    # Sampled point is left data state
                    return PrimitiveState(self.rhoL, self.uL, self.pL)

                else:
                    # Sampled point is either inside the star state or inside the fan
                    c_star = self.cL * (p_star / self.pL)**self.G1

                    if s > u_star - c_star:
                        # Sampled point is the left star state
                        rho_star = self.rhoL * (p_star / self.pL)**(1.0 / self.gamma)

                        return PrimitiveState(rho_star,u_star,p_star)
                    else:
                        # Sampled point is inside the rarefaction fan
                        c = self.G5 * (self.cL + self.G7 * (self.uL - s))
                        rho_fan = self.rhoL * (c / self.cL)**self.G4
                        u_fan = self.G5 * (self.cL + self.G7 * self.uL + s)
                        p_fan = self.pL * (c / self.cL)**self.G3

                        return PrimitiveState(rho_fan, u_fan, p_fan)
            else:
                # Left Shock

                p_ratio = p_star / self.pL
                shock_speed = self.uL - self.cL * np.sqrt(self.G2 * p_ratio + self.G1)

                if s <= shock_speed:
                    # Sampled point is left data state
                    return PrimitiveState(self.rhoL,self.uL,self.pL)
                else:
                    # Sampled point is left start state
                    rho_star = self.rhoL * (p_ratio + self.G6) / (p_ratio * self.G6 + 1.0)
                    return PrimitiveState(rho_star, u_star, p_star)

        else:
            # Sampling point lies to the right of the contact discontinuity

            if p_star > self.pR:
                # Right Shock
                p_ratio = p_star / self.pR
                shock_speed = self.uR + self.cR * np.sqrt(self.G2 * p_ratio + self.G1)

                if s >= shock_speed:
                    # Sampled point is right data state
                    return PrimitiveState(self.rhoR,self.uR,self.pR)
                else:
                    # Sampled point is right star state
                    rho_star = self.rhoR * (p_ratio + self.G6) / (p_ratio * self.G6 + 1.0)
                    return PrimitiveState(rho_star, u_star, p_star)

            else:
                # Right rarefaction

                if s >= self.uR + self.cR:
                    # Sampled point is left data state
                    return PrimitiveState(self.rhoL, self.uL, self.pL)

                else:
                    # Sampled point is either inside the star state or inside the fan
                    c_star = self.cL * (p_star / self.pL)**self.G1

                    if s > u_star - c_star:
                        # Sampled point is the left star state
                        rho_star = self.rhoL * (p_star / self.pL)**(1.0 / self.gamma)

                        return PrimitiveState(rho_star,u_star,p_star)
                    else:
                        # Sampled point is inside the rarefaction fan
                        c = self.G5 * (self.cL + self.G7 * (self.uL - s))
                        rho_fan = self.rhoL * (c / self.cL)**self.G4
                        u_fan = self.G5 * (self.cL + self.G7 * self.uL + s)
                        p_fan = self.pL * (c / self.cL)**self.G3

                        return PrimitiveState(rho_fan, u_fan, p_fan)